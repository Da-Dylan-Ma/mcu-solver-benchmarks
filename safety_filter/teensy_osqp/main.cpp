/*
 * This file was autogenerated by OSQP on Tue Feb 20 00:00:21 2024
 *
 * This file contains a sample solver to run the embedded code.
 */

#include <stdio.h>
#include <stdlib.h>
#include "osqp.h"
#include "osqp_data_workspace.h"
#include "math.h"

// in osqp_problem.h
#define NSTATES 6
#define NINPUTS 3
#define NHORIZON 30

#define NTOTAL 201
#define NRUNS (NTOTAL - NHORIZON - 1)
#define dt 0.05

float kp = 7.0;
float kd = 3.0;
float ki = 0.1;

void add_noise(OSQPFloat x[], float var)
{
  for (int i = 0; i < NSTATES; ++i)
  {
    OSQPFloat noise = ((rand() / RAND_MAX) - 0.5) * 2; // random -1 to 1
    x[i] += noise * var;
  }
}
{
  for (int i = 0; i < NSTATES; ++i)
  {
    OSQPFloat noise = ((rand() / RAND_MAX) - 0.5) * 2; // random -1 to 1
    x[i] += noise * 0.01;
  }
}

void print_vector(OSQPFloat xn[], int n)
{
  for (int i = 0; i < n; ++i)
  {
    // Serial.println(xn[i]);
    printf("%f, ", xn[i]);
  }
}

void matrix_vector_mult(int n1,
                        int n2,
                        OSQPFloat matrix[],
                        OSQPFloat vector[],
                        OSQPFloat result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void matrix_vector_reset_mult(int n1,
                              int n2,
                              OSQPFloat matrix[],
                              OSQPFloat vector[],
                              OSQPFloat result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    result_vector[i] = 0.0;
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void system_dynamics(OSQPFloat xn[], OSQPFloat x[], OSQPFloat u[], OSQPFloat A[], OSQPFloat B[])
{
  matrix_vector_reset_mult(NSTATES, NSTATES, A, x, xn);
  matrix_vector_mult(NSTATES, NINPUTS, B, u, xn);
}

void compute_q(OSQPFloat q[], OSQPFloat R[], OSQPFloat uref[])
// uref is Nh-1 x Nu
// q is Nh x (Nx + 1) + Nh-1 x Nu
// Q_data is Nu x Nu
{
  for (int i = 0; i < NHORIZON-1; ++i)
  {
    matrix_vector_reset_mult(NINPUTS, NINPUTS, R, uref + (i * NINPUTS), q + (NHORIZON * NSTATES) + (i * NINPUTS));
  }
}

void compute_bound(OSQPFloat bnew[], OSQPFloat xn[], OSQPFloat xb, OSQPFloat ub, int size)
{
  for (int i = 0; i < NSTATES; ++i)
  {
    bnew[i] = -xn[i]; // only the first is current state
  }
  for (int i = (NHORIZON + 1) * NSTATES; i < (NHORIZON + 1) * NSTATES * 2; ++i)
  {
    bnew[i] = xb; // bounds on x
  }
  for (int i = (NHORIZON + 1) * NSTATES * 2; i < size; ++i)
  {
    bnew[i] = ub; // bounds on u
  }
}

OSQPFloat compute_norm(OSQPFloat x[], OSQPFloat x_bar[])
{
  OSQPFloat res = 0.0f;
  for (int i = 0; i < NSTATES; ++i)
  {
    res += (x[i] - x_bar[i]) * (x[i] - x_bar[i]);
  }
  return sqrt(res);
}

OSQPInt exitflag;
OSQPFloat xk[NSTATES] = {0};
OSQPFloat xhrz[NSTATES] = {0};
OSQPFloat xd[NSTATES] = {0};
OSQPFloat q_new[SIZE_Q] = {0};
OSQPFloat l_new[SIZE_LU] = {0};
OSQPFloat u_new[SIZE_LU] = {0};
OSQPFloat xmin = -10000.0;
OSQPFloat xmax = 10000;
OSQPFloat umin = -3.0;
OSQPFloat umax = 3;
OSQPFloat uref[NINPUTS * (NHORIZON - 1)] = {0};
OSQPFloat uk[NINPUTS] = {0};

int main()
{
  OSQPInt exitflag;
  int NPOS = (NSTATES / 2);
  srand(1);
  add_noise(xk, 0.01);

  for (int step = 0; step < NRUNS; step++)
  {
    memcpy(xhrz, xk, NSTATES * (sizeof(OSQPFloat)));
    // Rollout the nominal system
    for (int i = 0; i < NHORIZON - 1; ++i)
    {
      float temp = 2.0 * sin(1 * dt * step);
      for (int j = 0; j < NPOS; ++j)
      {
        xd[j] = temp;
      }
      // pid controller
      for (int j = 0; j < NINPUTS; ++j)
      {
        uref[j] = kp * (xd[j] - xk[j]) + kd * (xd[j + NPOS] - xk[j + NPOS]);
      }
      system_dynamics(xd, xhrz, uref, A, B);
      memcpy(xhrz, xd, NSTATES * (sizeof(OSQPFloat)));
    }
    memcpy(uk, uref, NINPUTS * (sizeof(OSQPFloat)));
    if (1) {  // enable safety filter
      compute_bound(l_new, xk, xmin, umin, SIZE_LU);
      compute_bound(u_new, xk, xmax, umax, SIZE_LU);
      compute_q(q_new, R, uref);
      osqp_update_data_vec(&osqp_data_solver, q_new, l_new, u_new);
      unsigned long start = micros();
      exitflag = osqp_solve(&osqp_data_solver);
      unsigned long end = micros();
      }

    system_dynamics(xd, xk, (osqp_data_solver.solution->x) + (NHORIZON + 1) * NSTATES, A, B);
    memcpy(xk, xd, NSTATES * (sizeof(OSQPFloat)));
  }
}
